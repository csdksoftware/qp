package qp

import (
	"reflect"
	"testing"
)

// Test if the types live up to their interface
var (
	_ binaryBothWayer = (*StatDotu)(nil)
	_ Message         = (*AuthRequestDotu)(nil)
	_ Message         = (*AttachRequestDotu)(nil)
	_ Message         = (*ErrorResponseDotu)(nil)
	_ Message         = (*CreateRequestDotu)(nil)
	_ Message         = (*StatResponseDotu)(nil)
	_ Message         = (*WriteStatRequestDotu)(nil)
)
var testsdotu = []struct {
	in        interface{}
	reference []byte
}{
	{
		&StatDotu{
			Type:       0xDEAD,
			Dev:        0xABCDEF08,
			Qid:        Qid{},
			Mode:       FileMode(OTRUNC),
			Atime:      90870987,
			Mtime:      1234124,
			Length:     0x23ABDDF8,
			Name:       "hello",
			UID:        "someone",
			GID:        "over the",
			MUID:       "rainbow",
			Extensions: "hello",
			UIDno:      23452345,
			GIDno:      34652,
			MUIDno:     2363457,
		},
		[]byte{0x5d, 0x0, 0xad, 0xde, 0x8, 0xef, 0xcd, 0xab, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0xcb, 0x94, 0x6a, 0x5, 0xcc, 0xd4, 0x12, 0x0, 0xf8, 0xdd, 0xab, 0x23, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x7, 0x0, 0x73, 0x6f, 0x6d, 0x65, 0x6f, 0x6e, 0x65, 0x8, 0x0, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x7, 0x0, 0x72, 0x61, 0x69, 0x6e, 0x62, 0x6f, 0x77, 0x5, 0x0, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0xb9, 0xda, 0x65, 0x1, 0x5c, 0x87, 0x0, 0x0, 0x41, 0x10, 0x24, 0x0},
	}, {
		&AuthRequestDotu{
			Tag:      45,
			AuthFid:  Fid(1234),
			Username: "someone",
			Service:  "something",
			UIDno:    3546298,
		},
		[]byte{0x23, 0x0, 0x0, 0x0, 0x66, 0x2d, 0x0, 0xd2, 0x4, 0x0, 0x0, 0x7, 0x0, 0x73, 0x6f, 0x6d, 0x65, 0x6f, 0x6e, 0x65, 0x9, 0x0, 0x73, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67, 0xba, 0x1c, 0x36, 0x0},
	}, {
		&AttachRequestDotu{
			Tag:      45,
			Fid:      35243,
			AuthFid:  90872354,
			Username: "",
			Service:  "weee",
			UIDno:    2563457,
		},
		[]byte{0x1b, 0x0, 0x0, 0x0, 0x68, 0x2d, 0x0, 0xab, 0x89, 0x0, 0x0, 0x22, 0x9a, 0x6a, 0x5, 0x0, 0x0, 0x4, 0x0, 0x77, 0x65, 0x65, 0x65, 0x81, 0x1d, 0x27, 0x0},
	}, {
		&ErrorResponseDotu{
			Tag:   45,
			Error: "something something something",
			Errno: 345324,
		},
		[]byte{0x2a, 0x0, 0x0, 0x0, 0x6b, 0x2d, 0x0, 0x1d, 0x0, 0x73, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67, 0xec, 0x44, 0x5, 0x0},
	}, {
		&CreateRequestDotu{
			Tag:         45,
			Fid:         12343,
			Name:        "wakakaaka",
			Permissions: DMDIR,
			Mode:        4,
			Extensions:  "qefdasiuh",
		},
		[]byte{0x26, 0x0, 0x0, 0x0, 0x72, 0x2d, 0x0, 0x37, 0x30, 0x0, 0x0, 0x9, 0x0, 0x77, 0x61, 0x6b, 0x61, 0x6b, 0x61, 0x61, 0x6b, 0x61, 0x0, 0x0, 0x0, 0x80, 0x4, 0x9, 0x0, 0x71, 0x65, 0x66, 0x64, 0x61, 0x73, 0x69, 0x75, 0x68},
	}, {
		&StatResponseDotu{
			Tag:  45,
			Stat: StatDotu{},
		},
		[]byte{0x48, 0x0, 0x0, 0x0, 0x7d, 0x2d, 0x0, 0x3f, 0x0, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	}, {
		&WriteStatRequestDotu{
			Tag:  45,
			Fid:  12342134,
			Stat: StatDotu{},
		},
		[]byte{0x4c, 0x0, 0x0, 0x0, 0x7e, 0x2d, 0x0, 0x76, 0x53, 0xbc, 0x0, 0x3f, 0x0, 0x3d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
	},
}

// This test does NOT guarantee proper 9P2000 spec coding, but ensures at least
// that all codecs are compatible with themselves.
func TestReencodeDotu(t *testing.T) {
	for i, tt := range testsdotu {
		r := reflect.New(reflect.ValueOf(tt.in).Elem().Type()).Interface().(binaryBothWayer)
		x := make([]byte, len(tt.reference)-6)
		copy(x, tt.reference[5:])
		testUnmarshal(t, i, r, x)
	}
}

// This test does NOT guarantee proper 9P2000 spec coding, but ensures at least
// that all codecs are compatible with themselves.
func TestUnmarshalErrorDotu(t *testing.T) {
	for i, tt := range testsdotu {
		reencode(i, tt.in, tt.reference, t, NineP2000Dotu)
	}
}
